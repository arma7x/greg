{"id":"../node_modules/ical/node-ical.js","dependencies":[{"name":"/home/arma7x/Desktop/New/kaios/greg/package.json","includedInParent":true,"mtime":1656033706613},{"name":"/home/arma7x/Desktop/New/kaios/greg/node_modules/ical/package.json","includedInParent":true,"mtime":1655998719736},{"name":"./ical","loc":{"line":1,"column":19,"index":19},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/ical/node-ical.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/ical/ical.js"},{"name":"fs","loc":{"line":2,"column":17,"index":46},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/ical/node-ical.js","resolved":"/usr/lib/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"rrule","loc":{"line":8,"column":20,"index":174},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/ical/node-ical.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/index.js"}],"generated":{"js":"var ical = require('./ical')\n  , fs = require('fs')\n\nexports.parseFile = function(filename){\n  return ical.parseICS(fs.readFileSync(filename, 'utf8'))\n}\n\nvar rrule = require('rrule').RRule\n\nical.objectHandlers['RRULE'] = function(val, params, curr, stack, line){\n  curr.rrule = line;\n  return curr\n}\nvar originalEnd = ical.objectHandlers['END'];\nical.objectHandlers['END'] = function (val, params, curr, stack) {\n\t// Recurrence rules are only valid for VEVENT, VTODO, and VJOURNAL.\n\t// More specifically, we need to filter the VCALENDAR type because we might end up with a defined rrule\n\t// due to the subtypes.\n\tif ((val === \"VEVENT\") || (val === \"VTODO\") || (val === \"VJOURNAL\")) {\n\t\tif (curr.rrule) {\n\t\t\tvar rule = curr.rrule.replace('RRULE:', '');\n\t\t\tif (rule.indexOf('DTSTART') === -1) {\n\n\t\t\t\tif (curr.start.length === 8) {\n\t\t\t\t\tvar comps = /^(\\d{4})(\\d{2})(\\d{2})$/.exec(curr.start);\n\t\t\t\t\tif (comps) {\n\t\t\t\t\t\tcurr.start = new Date(comps[1], comps[2] - 1, comps[3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (typeof curr.start.toISOString === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trule += ';DTSTART=' + curr.start.toISOString().replace(/[-:]/g, '');\n\t\t\t\t\t\trule = rule.replace(/\\.[0-9]{3}/, '');\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(\"ERROR when trying to convert to ISOString\", error);\n\t\t\t\t\t}\n                } else {\n                    console.error(\"No toISOString function in curr.start\", curr.start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr.rrule = rrule.fromString(rule);\n\t\t}\n\t}\n  return originalEnd.call(this, val, params, curr, stack);\n}\n"},"sourceMaps":null,"error":null,"hash":"f01a6268ee9380e28b958b2fceb6e1b6","cacheData":{"env":{}}}