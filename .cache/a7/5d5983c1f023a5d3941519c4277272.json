{"id":"../node_modules/rrule/dist/esm/rrulestr.js","dependencies":[{"name":"/home/arma7x/Desktop/New/kaios/greg/package.json","includedInParent":true,"mtime":1656000240012},{"name":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/package.json","includedInParent":true,"mtime":1655998719762},{"name":"./rrule","loc":{"line":1,"column":18,"index":18},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrulestr.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrule.js"},{"name":"./rruleset","loc":{"line":2,"column":21,"index":50},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrulestr.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rruleset.js"},{"name":"./dateutil","loc":{"line":3,"column":21,"index":85},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrulestr.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/dateutil.js"},{"name":"./weekday","loc":{"line":4,"column":24,"index":123},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrulestr.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/weekday.js"},{"name":"./helpers","loc":{"line":5,"column":32,"index":168},"parent":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/rrulestr.js","resolved":"/home/arma7x/Desktop/New/kaios/greg/node_modules/rrule/dist/esm/helpers.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rrule = _interopRequireDefault(require(\"./rrule\"));\n\nvar _rruleset = _interopRequireDefault(require(\"./rruleset\"));\n\nvar _dateutil = _interopRequireDefault(require(\"./dateutil\"));\n\nvar _weekday = require(\"./weekday\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * RRuleStr\n *  To parse a set of rrule strings\n */\nvar RRuleStr =\n/** @class */\nfunction () {\n  function RRuleStr() {\n    // tslint:disable:variable-name\n    this._handle_BYDAY = this._handle_BYWEEKDAY;\n    this._handle_INTERVAL = this._handle_int;\n    this._handle_COUNT = this._handle_int;\n    this._handle_BYSETPOS = this._handle_int_list;\n    this._handle_BYMONTH = this._handle_int_list;\n    this._handle_BYMONTHDAY = this._handle_int_list;\n    this._handle_BYYEARDAY = this._handle_int_list;\n    this._handle_BYEASTER = this._handle_int_list;\n    this._handle_BYWEEKNO = this._handle_int_list;\n    this._handle_BYHOUR = this._handle_int_list;\n    this._handle_BYMINUTE = this._handle_int_list;\n    this._handle_BYSECOND = this._handle_int_list; // tslint:enable:variable-name\n  } // tslint:disable-next-line:variable-name\n\n\n  RRuleStr.prototype._handle_DTSTART = function (rrkwargs, _, value, __) {\n    var parms = /^DTSTART(?:;TZID=([^:=]+))?(?::|=)(.*)/.exec(value);\n    var ___ = parms[0],\n        tzid = parms[1],\n        dtstart = parms[2];\n    rrkwargs['dtstart'] = _dateutil.default.untilStringToDate(dtstart);\n\n    if (tzid) {\n      rrkwargs['tzid'] = tzid;\n    }\n  };\n\n  RRuleStr.prototype._handle_int = function (rrkwargs, name, value) {\n    // @ts-ignore\n    rrkwargs[name.toLowerCase()] = parseInt(value, 10);\n  };\n\n  RRuleStr.prototype._handle_int_list = function (rrkwargs, name, value) {\n    // @ts-ignore\n    rrkwargs[name.toLowerCase()] = value.split(',').map(function (x) {\n      return parseInt(x, 10);\n    });\n  };\n\n  RRuleStr.prototype._handle_FREQ = function (rrkwargs, _, value, __) {\n    rrkwargs['freq'] = RRuleStr._freq_map[value];\n  };\n\n  RRuleStr.prototype._handle_UNTIL = function (rrkwargs, _, value, __) {\n    try {\n      rrkwargs['until'] = _dateutil.default.untilStringToDate(value);\n    } catch (error) {\n      throw new Error('invalid until date');\n    }\n  };\n\n  RRuleStr.prototype._handle_WKST = function (rrkwargs, _, value, __) {\n    rrkwargs['wkst'] = RRuleStr._weekday_map[value];\n  };\n\n  RRuleStr.prototype._handle_BYWEEKDAY = function (rrkwargs, _, value, __) {\n    // Two ways to specify this: +1MO or MO(+1)\n    var splt;\n    var i;\n    var j;\n    var n;\n    var w;\n    var wday;\n    var l = [];\n    var wdays = value.split(',');\n\n    for (i = 0; i < wdays.length; i++) {\n      wday = wdays[i];\n\n      if (wday.indexOf('(') > -1) {\n        // If it's of the form TH(+1), etc.\n        splt = wday.split('(');\n        w = splt[0];\n        n = parseInt(splt.slice(1, -1)[0], 10);\n      } else {\n        // # If it's of the form +1MO\n        for (j = 0; j < wday.length; j++) {\n          if ('+-0123456789'.indexOf(wday[j]) === -1) break;\n        }\n\n        n = wday.slice(0, j) || null;\n        w = wday.slice(j);\n        if (n) n = parseInt(n, 10);\n      }\n\n      var weekday = new _weekday.Weekday(RRuleStr._weekday_map[w], n);\n      l.push(weekday);\n    }\n\n    rrkwargs['byweekday'] = l;\n  };\n\n  RRuleStr.prototype._parseRfcRRule = function (line, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.dtstart = options.dtstart || null;\n    options.cache = options.cache || false;\n    var name;\n    var value;\n    var parts;\n    var nameRegex = /^([A-Z]+):(.*)$/;\n    var nameParts = nameRegex.exec(line);\n\n    if (nameParts && nameParts.length >= 3) {\n      name = nameParts[1];\n      value = nameParts[2];\n      if (name !== 'RRULE') throw new Error(\"unknown parameter name \" + name);\n    } else {\n      value = line;\n    }\n\n    var rrkwargs = {};\n    var dtstart = /DTSTART(?:;TZID=[^:]+:)?[^;]+/.exec(line);\n\n    if (dtstart && dtstart.length > 0) {\n      var dtstartClause = dtstart[0];\n\n      this._handle_DTSTART(rrkwargs, 'DTSTART', dtstartClause);\n    }\n\n    var pairs = value.split(';');\n\n    for (var i = 0; i < pairs.length; i++) {\n      parts = pairs[i].split('=');\n      name = parts[0].toUpperCase();\n\n      if (/DTSTART|TZID/.test(name)) {\n        continue;\n      }\n\n      value = parts[1].toUpperCase(); // @ts-ignore\n\n      var paramHandler = this[\"_handle_\" + name];\n\n      if (typeof paramHandler !== 'function') {\n        throw new Error(\"unknown parameter '\" + name + \"':\" + value);\n      }\n\n      paramHandler(rrkwargs, name, value);\n    }\n\n    rrkwargs.dtstart = rrkwargs.dtstart || options.dtstart;\n    rrkwargs.tzid = rrkwargs.tzid || options.tzid;\n    return new _rrule.default(rrkwargs, !options.cache);\n  };\n\n  RRuleStr.prototype._parseRfc = function (s, options) {\n    if (options.compatible) {\n      options.forceset = true;\n      options.unfold = true;\n    }\n\n    s = s && s.trim();\n    if (!s) throw new Error('Invalid empty string');\n    var i = 0;\n    var line;\n    var lines; // More info about 'unfold' option\n    // Go head to http://www.ietf.org/rfc/rfc2445.txt\n\n    if (options.unfold) {\n      lines = s.split('\\n');\n\n      while (i < lines.length) {\n        // TODO\n        line = lines[i] = lines[i].replace(/\\s+$/g, '');\n\n        if (!line) {\n          lines.splice(i, 1);\n        } else if (i > 0 && line[0] === ' ') {\n          lines[i - 1] += line.slice(1);\n          lines.splice(i, 1);\n        } else {\n          i += 1;\n        }\n      }\n    } else {\n      lines = s.split(/\\s/);\n    }\n\n    var rrulevals = [];\n    var rdatevals = [];\n    var exrulevals = [];\n    var exdatevals = [];\n    var name;\n    var value;\n    var parts;\n    var dtstart;\n    var tzid;\n    var rset;\n    var j;\n    var k;\n    var datestrs;\n    var datestr;\n\n    if (!options.forceset && lines.length === 1 && (s.indexOf(':') === -1 || s.indexOf('RRULE:') === 0)) {\n      return this._parseRfcRRule(lines[0], {\n        cache: options.cache,\n        dtstart: options.dtstart\n      });\n    } else {\n      for (var i_1 = 0; i_1 < lines.length; i_1++) {\n        line = lines[i_1];\n        if (!line) continue;\n\n        if (line.indexOf(':') === -1) {\n          name = 'RRULE';\n          value = line;\n        } else {\n          parts = (0, _helpers.split)(line, ':', 1);\n          name = parts[0];\n          value = parts[1];\n        }\n\n        var parms = name.split(';');\n        if (!parms) throw new Error('empty property name');\n        name = parms[0].toUpperCase();\n        parms = parms.slice(1);\n\n        if (name === 'RRULE') {\n          for (j = 0; j < parms.length; j++) {\n            var parm = parms[j];\n            throw new Error('unsupported RRULE parm: ' + parm);\n          }\n\n          rrulevals.push(value);\n        } else if (name === 'RDATE') {\n          for (j = 0; j < parms.length; j++) {\n            var parm = parms[j];\n\n            if (parm !== 'VALUE=DATE-TIME' && parm !== 'VALUE=DATE') {\n              throw new Error('unsupported RDATE parm: ' + parm);\n            }\n          }\n\n          rdatevals.push(value);\n        } else if (name === 'EXRULE') {\n          for (j = 0; j < parms.length; j++) {\n            var parm = parms[j];\n            throw new Error('unsupported EXRULE parm: ' + parm);\n          }\n\n          exrulevals.push(value);\n        } else if (name === 'EXDATE') {\n          for (j = 0; j < parms.length; j++) {\n            var parm = parms[j];\n\n            if (parm !== 'VALUE=DATE-TIME' && parm !== 'VALUE=DATE') {\n              throw new Error('unsupported EXDATE parm: ' + parm);\n            }\n          }\n\n          exdatevals.push(value);\n        } else if (name === 'DTSTART') {\n          dtstart = _dateutil.default.untilStringToDate(value);\n\n          if (parms.length) {\n            var _a = parms[0].split('='),\n                key = _a[0],\n                value_1 = _a[1];\n\n            if (key === 'TZID') {\n              tzid = value_1;\n            }\n          }\n        } else {\n          throw new Error('unsupported property: ' + name);\n        }\n      }\n\n      if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {\n        rset = new _rruleset.default(!options.cache);\n\n        for (j = 0; j < rrulevals.length; j++) {\n          rset.rrule(this._parseRfcRRule(rrulevals[j], {\n            // @ts-ignore\n            dtstart: options.dtstart || dtstart\n          }));\n        }\n\n        for (j = 0; j < rdatevals.length; j++) {\n          datestrs = rdatevals[j].split(',');\n\n          for (k = 0; k < datestrs.length; k++) {\n            datestr = datestrs[k];\n            rset.rdate(_dateutil.default.untilStringToDate(datestr));\n          }\n        }\n\n        for (j = 0; j < exrulevals.length; j++) {\n          rset.exrule(this._parseRfcRRule(exrulevals[j], {\n            // @ts-ignore\n            dtstart: options.dtstart || dtstart\n          }));\n        }\n\n        for (j = 0; j < exdatevals.length; j++) {\n          datestrs = exdatevals[j].split(',');\n\n          for (k = 0; k < datestrs.length; k++) {\n            datestr = datestrs[k];\n            rset.exdate(_dateutil.default.untilStringToDate(datestr));\n          }\n        } // @ts-ignore\n\n\n        if (options.compatible && options.dtstart) rset.rdate(dtstart);\n        return rset;\n      } else {\n        return this._parseRfcRRule(rrulevals[0], {\n          // @ts-ignore\n          dtstart: options.dtstart || dtstart,\n          cache: options.cache,\n          // @ts-ignore\n          tzid: options.tzid || tzid\n        });\n      }\n    }\n  };\n\n  RRuleStr.prototype.parse = function (s, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var invalid = [];\n    var keys = Object.keys(options);\n    var defaultKeys = Object.keys(RRuleStr.DEFAULT_OPTIONS);\n    keys.forEach(function (key) {\n      if (!(0, _helpers.includes)(defaultKeys, key)) invalid.push(key);\n    }, this);\n\n    if (invalid.length) {\n      throw new Error('Invalid options: ' + invalid.join(', '));\n    } // Merge in default options\n\n\n    defaultKeys.forEach(function (key) {\n      if (!(0, _helpers.includes)(keys, key)) options[key] = RRuleStr.DEFAULT_OPTIONS[key];\n    });\n    return this._parseRfc(s, options);\n  }; // tslint:disable-next-line:variable-name\n\n\n  RRuleStr._weekday_map = {\n    MO: 0,\n    TU: 1,\n    WE: 2,\n    TH: 3,\n    FR: 4,\n    SA: 5,\n    SU: 6\n  }; // tslint:disable-next-line:variable-name\n\n  RRuleStr._freq_map = {\n    YEARLY: _rrule.default.YEARLY,\n    MONTHLY: _rrule.default.MONTHLY,\n    WEEKLY: _rrule.default.WEEKLY,\n    DAILY: _rrule.default.DAILY,\n    HOURLY: _rrule.default.HOURLY,\n    MINUTELY: _rrule.default.MINUTELY,\n    SECONDLY: _rrule.default.SECONDLY\n  };\n  RRuleStr.DEFAULT_OPTIONS = {\n    dtstart: null,\n    cache: false,\n    unfold: false,\n    forceset: false,\n    compatible: false,\n    tzid: null\n  };\n  return RRuleStr;\n}();\n\nvar _default = RRuleStr;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"db98c44fe3e1aaa458c948a41a51a657","cacheData":{"env":{}}}